# 現場Rails Chapter4-5

・使用制限をかけるためにログイン機能を作り、認証を行う。そうすることでアプリケーションがユーザーを具体的に把握することができる。把握ができれば制限をかけることができる。

・HTTPはスレートレス（状態を保持しない）なプロトコルなため、そのままでは、同じユーザーから送られてきた１つ目のリクエストから２つ目のリクエストに情報を引き継ぐことはできない。そのためWebアプリケーションはサーバー側にセッションという仕組みを利用して、１つのブラウザから連続して送られる一連のリクエスト間で「状態」を共有できるようにする。

・Railsではコントローラからsessionというメソッドを呼び出すことができ、セッションにアクセスすることができる。sessionはハッシュのように扱うことができる。セッションにデータを入れるには、任意のキーを指定して値を格納する。
session[:user_id] = @user.id # セッションに値を格納
@user_id = session[:user_id] # 値を取り出す

・セッションがアプリケーションサーバー側で独自に実装される仕組みであるのに対して、CookieはブラウザとWebサーバーの間でやりとりされる、より汎用的な仕組みである。

・CookieではまずWebサーバーからブラウザへHTTPレスポンスを返す際に、何らかのCookie情報を含めて送る。Cookie情報はキーと値のペア集合であり、ブラウザはこのCookie情報を、サーバーのドメイン情報に紐づけて保持する。そして次に同じドメインに対してHTTPリクエストを送る際に、保管していたCookie情報を添えて送る。これによってWebサーバーは、以前にどのようなCookie情報を受け取ったブラウザからリクエストが送られてきたのかを知ることができる。いわば、Cookieは複数のリクエストの間で共有したい「状態」をブラウザ側に保存する仕組みである。

・Railsでは、Cookieというメソッドでブラウザから受け取り、送り出すことになるCookie情報にアクセスし、データを取得したり設定することができる。基本的にはセッションを使えば済むため、直接Cookieを操作することはない。それよりもRailsのセッションの仕組みの一部が、Cookieによって実現されているということを把握することが重要である。デフォルトのセッションデータの保管場所もCookieになっているし、保管場所を複数の選択肢から選ぶことができる。そのためブラウザ側で対応するCookieデータを消せば、セッションはリセットされることになる。

・has_secure_passwordを使用することでpasswordを一時的に格納するための属性を扱うことができる。has_secure_passwordを使用するにはセットで生のパスワードをハッシュ化して保存するbcryptというgemを使用する。

・Admin::UsersControllerのようにモジュール階層をコードを保存するためのディレクトリ階層に対応させているため、このようにするとapp/controllers/admin/users_controller.rbというファイルが対応することになる。

・routes.rbで使用される、namespaceはコントローラーを名前空間によってグループ化することができる。

・Railsでログイン機能を実装する際は、ログインをする＝「セッションというリソースを作る」と捉えて、SessionsControllerという名前でコントローラを作ることがよく行われる。

・findメソッドはidのみで検索ができ、見つからない場合はエラーを返すが、find_byは特定の条件を指定でき、見つからない場合はnilを返す。

・session[:user_id] = user.idと格納することでログイン後はセッションが生きている限り、user = User.find_by(id: session[:user_id])でユーザーを簡単に取得することができる。この処理は頻繁に必要になるため、コントローラーやビューから簡単に呼べるようにするのが定石となる。簡単な実現方法としてApplicationControllerにcurrent_userというようなメソッドを定義しておくこと。そしてhelper_method指定することで、全てのビューからも使用できる。publicなメソッドではないため、privateメソッドに定義するが吉。

・開発上不便なためログイン機能を実装したら、まずはログアウト機能を実装すること。

・session.delete(:user_id)でセッションを削除できるが、他の情報も入れている場合で、全てのセッション情報を削除したい場合はreset_sessionメソッドを使用すること。

・コントローラにはフィルタという機能を設けることができる。これはコールバックと似た概念で、アクションを処理する前後で、任意の処理を挟むことができる。例えば各アクションの前に処理するフィルタで、ログインしているかどうか確認し、もしログインしていなければログイン画面に遷移するといったことができる。フィルタもコールバックと同様に、フィルタとしてメソッドを登録し、実際にそのメソッドを実装するというやり方で追加する。
そしてフィルタを設定するときは、before_actionを用いてオプションも付与できる。skip_before_actionも忘れずに。

・1対多の関係の時は、多テーブルの方に1を示す#{1のモデル名}_id外部キーを持たせる。

・Railsには「関連(Association)」という仕組みが用意されている。データベース上の紐付けを前提にして、モデルクラス同志の紐付けを定義することができる。これによってオブジェクト指向に沿ったやり方で、関連するデータにアクセスすることができる。

・has_many, belongs_toといった関連づけを行うことで、例えばuser.tasksといったメソッドで、紐づいたTaskオブジェクトの一覧を得られるようになる。この定義は必ずしもする必要はなく、メソッドで便利に特定のオブジェクトに紐づいたオブジェクトを取得したいときに行えば良い。もしもRubyレベルでの便利機能が不要なのであれば、関連を定義せずに単に外部キーのカラムを利用するだけにとどめておいても構わない。

・user.tasks.new(task_params)とuser.tasks.build(task_params)の違いはuser_idに値が入るかどうかの違いだが、現在ではどちらでも良い。ただ慣習的にはbuildが好ましい。可読性も上がる。
また前者はuserオブジェクトが内部的に抱えるtaskリストを変更し、後者は変更しない。このため保存に失敗したtaskオブジェクトを抱える状況を避けたいときはnewよりもbuildがいい。そもそも最初からbuildを使用した方がいい。

・admin?メソッドはそのオブジェクトが管理者かどうか評価してくれる。管理者コントローラーにはbefore_actionでrequire_loginといったメソッドを定義するとよい。
最初の管理者ユーザーを作る場合は、Rails Consoleで作成すれば良い。最も良いのは初期データ投入の方法のseedという仕組みを利用すること。
